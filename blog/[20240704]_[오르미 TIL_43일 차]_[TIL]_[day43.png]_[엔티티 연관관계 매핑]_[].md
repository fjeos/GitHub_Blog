## 🍃Spring Data JPA
- JPA 는 쿼리를 모아놨다가 flush를 만나면 DB에 반영
- 쿼리를 모아놓는 공간이 영속성 컨텍스트
- 장점: DB에 접근하는 비용을 최소화

엔티티에서 세터 어노테이션은 쓰지 않아요
셋 메소드를 만들어서 명시적으로 표기를 하던지...

![springdata](img/content/springdata.png)
- Spring Data 종류
- 다양한 DB의 데이터를 핸들링 할 수 있음
- 스프링에서 사용할 수 있는 데이터 접근 기술들을 스프링이 wrapping 해서 제공한 게 spring-data
- spring-data-jpa는 spring-data 중에서도 JPA와 관련된 것  


**❓하이버네이트와 스프링데이터의 차이**  
- 하이버네이트는 jpa쪽, 스프링데이터는 spring 쪽
- spring data jpa는 그 둘을 합쳐서 편하게 사용하도록 제공

#### JPA 정리
- java에서 persistence레벨에 접근할 수 있는 api, persistence는 db
- 그 표준을 jpa라고 함
- 데이터베이스를 다루는 인터페이스
- 실제 구현체가 hibernate
- orm기술
&nbsp;&nbsp;&nbsp;&nbsp;- 테이블과 엔티티를 매핑(RDBMS-Object 매핑)
&nbsp;&nbsp;&nbsp;&nbsp;- 엔티티로 상태 관리, 데이터를 저장하고 싶을때는 필요한 시점에 commit을 해야함
- commit이랑 flush까지 신경쓸 경우에는 hibernate를 직접 쓰는 경우
- spring data jpa를 사용하면 flush까지 신경쓰지 않아도 됨

#### Spring Data JPA 사용하기
- spring data jpa는 jpa와 hibernate의 기능도 추상화된 상태
- 알아서 쿼리를 만들어줌
- `@Id` = PK
- `@GernatedValue` 키 자동 생성
- strategy: 세개가 있는데 주로 IDENTITY 사용, DBMS의 키 자동 생성 전략을 따름
- `@Column`: 열 지정, 속성 중 insertable과 updatable은 잘 사용하지 않음

- application-properties에서 ddl-auto 옵션을 create로 하면 테이블 자동 생성
- 하지만 테이블이 이미 존재하면 drop 후 다시 생성하기 때문에 사용하면 안 됨
- 다른 옵션은 사용하기도 함

- @Entity의 name -> JPA에서 사용할 엔티티 이름 지정, 기본값은 클래스 이름 사용

- @Table의 name- > 매핑할 테이블 이름, 기본값은 엔티티 이름 사용

- Sequence: 오라클에서 많이 사용, 테이블처럼 사용하는 개념
- Table: 키를 관리하는 테이블을 생성해놓고 거기서 값을 가져오겠다

#### 식별자 선택 전략
1. null이 아닌 값
2. 중복되지 않는 유일한 값
3. 변하면 안되는 값

- 자연키: 비즈니스에 의미가 있는 키: 이메일, 전화번호, 주민등록번호 => 고유하지 않음
- 키에는 비즈니스 적인 의미가 있으면 안됨(개인과 관련된 유니크한 정보들)

- 대리키: 비즈니스와 관련 없는 임의로 만들어진 키 => 오토 인크리먼트, 오라클 시퀀스, 키생성 테이블  
-> DBMS 한테 키 생성을 맡김  

@Column에서 name을 지정하지 않으면 디폴트로 필드명 사용
unique: 유니크 여부
columnDefinition -> 컬럼 정보 직접 설정, default값 설정 가능

@Enumerated : enum 타입의 상수값을 테이블 컬럼에 매핑
@Temporal : 날짜 타입 매핑

## 🤼엔티티와 연관관계 매핑

연관관계 매핑
연관관계 매핑이란... 두 테이블 간의 조인을 할 때..
PK랑 FK로 조인하는건 RDBMS 기준
RDBMS(각각의 테이블)를 Object(엔티티)로 매핑을 함
그러면 엔티티끼리도 매핑을 해줘야 함

엔티티 연관관계 매핑은 방향성도 있음
RDBMS에서는 어떤 연관관계도 join을 하면 두 테이블을 모두 조회할 수 있었음
 -> 방향성이 없다
엔티티 연관관계는 참조를 해야함 -> 방향성이 생김
조인 효과를 내기 위해선 오브젝트에서는 참조를 해야함

SQL문으로 Join을 할 경우 테이블을 병합하지만 JPA에서는 병합하지 않고 참조하는 관계를 가진다는 말씀이신가요?? -> 네 맞습니다

양방향 참조는 사실 불가능 -> 단방향만 가능하지만, 둘다 참조를 걸어줘서 양방향처럼 보이게

보통 일대다 관계에서 다 쪽이 연관관계의 주인
DBMS에서 FK를 가지고 있는 쪽이 연관관계의 주인이 됨

객체 연관관계 -> Object 매핑
테이블 연관관계 -> RDBMS 기준

왜 멤버가 연관관계의 주인일까?
회원이 팀에 속해있는 구조
A의 팀이 바뀌면 멤버 테이블의 team_id 컬럼을 바꿔야 함
주체가 되는 테이블에 @ManyToOne을 붙임
그리고@JoinColumn해주기 name은 상대 테이블의 어떤 컬럼을 FK로 들고 있는지 표기
@JoinColumn(name = "TEAM_ID")
상대 테이블의 컬럼에는 @Column(name = "TEAM_ID")로 지정

일대다 단방향이 가장 많이 사용됨
양방향 연관관계는 지양함
단방향을 주로 사용하면 됨
양방향 연관관계에서 로딩 방식에 따라서 우리가 원하는대로 쿼리가 실행되지 않을 수 있음
연관관계의 주인이 참조하게 될 엔티티를 들고있음


deprecated : 더이상 사용하지 않는다
흐름을 알고 있는것이 중요
너무 딥한것 까지는.. 모르겠지만
기본 개념도 굉장히 중요하기때문에 그 부분을 물어볼거예요

maven이 로컬에다가 라이브러리를 다운받는 것
디펜던시에 키워드를 추가하면 해당하는 라이브러리를 가져옴(아마두..)