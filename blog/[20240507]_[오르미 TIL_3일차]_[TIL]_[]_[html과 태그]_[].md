

## 백엔드 개발자가 프론트를 공부하는 이유?
- 개인 프로젝트에 용이
- 피드백, 성능개선 -> 반복하다보면 성능 최적화 가능
- 프론트 개발자의 고민: 어떻게 빠르게 화면에 보여줄 수 있을까  


## HTML 태그
- 웹 문서에 정보를 정의해주는 형식
- <>시작태그(여는태그)와 </>종료태그(닫는태그)의 쌍으로 구성
- 여는 태그와 닫는 태그 사이에는 컨텐츠가 들어감
- 빈 태그: 컨텐츠 영역이 없어서 닫는 태그도 없음
- 컨텐츠는 다른 html 태그나 문자 등 다양한 정보가 들어갈 수 있음
- 이를 합쳐서 요소(element)라고 함  

## 브라우저
- 개발자 도구 -> Elements에서 위쪽은 html 정보, 아래는 css 정보
- console: 자바스크립트를 실행시켜주는 실행화면
- network: 백엔드와 프론트가 통신할때 어떤 데이터가 오고가는지 정보
- 문법 오류는 브라우저가 임의로 처리 -> 편리할 수 있으나 의도치 않은 결과가 나타날 수 있음
    - 이를 방지하기 위해서는 마크업 검사 진행(웹 표준을 준수했는지 검사)
- 왜 브라우저는 오류를 임의로 처리할까? -> 일단 보여줘야 하니까, 사용자의 사용성 보장  

### 브라우저에서 위에서부터 렌더링 되는 이유
- 인터넷이 느렸던 그시절... 데이터를 전부 받고 렌더링하는 것보다 받아지는 대로 렌더링을 하는게 그나마 사용자 경험이 좋다
- 그래서 아래는 아직 안 떠도 위 부분의 정보는 볼 수 있다  

## 컴파일러 언어 vs 인터프리터 언어
- 컴파일러 내장 언어: 코드를 기계어로 번역해주는 컴파일러가 기본적으로 체킹을 다 함
    -> 그래서 문법적인 에러가 발생할 확률은 거의 없음
- 인터프리터 언어: 별도의 컴파일 과정을 거치지 않고 바로 읽어서 화면에 렌더링하기 때문에 사용자가 브라우저에서 보기 전까지 어떤 에러가 있는지 알 수 없음
- html은 인터프리터 언어의 일종  

## html
- html은 부모, 형제, 자식, 자손의 개념이 있다
![html_relationship](img/content/html가족관계.png)
- 조카는 없음..^^ <br/>
#### \<!DOCTYPE html\>
- html living standard 문서라는 의미= DTD(Document Type Definition)
- 이제는 html 버전이 아니라 리빙 스탠다드라고 한대
- 사용자들의 개선 요구를 바로 반영할 수 있도록 함
- 쿼크 모드(quirks mode): 하휘 호환성 모드, DOCTYPE을 안 쓰면 작동  

### \<html\>
- html 문서의 최상단 태그(root 요소)
- html태그 안에 lang은 주 언어를 지정 \<html lang = "en"\>
- 디폴트는 영어, 한국은 ko
- 주 언어 설정은 검색엔진, 스크린리더, 번역 기능 제공 등에 영향
- 스크린리더: 배리어 프리를 위해 화면을 읽어주는 프로그램
- OS에 내부적으로 스크린리더 프로그램이 있음
- 프로그램이 화면을 읽는게 아니라 프론트에서 정보를 넣어놨기 때문에 가능한 것
- 주 언어가 한국어여도 부분적으로 언어 설정을 할 수 있음  


### \<head\>
- 기계가 식별할 수 있는 문서 정보(메타데이터)를 담음
- 사용자에게 보여주기 위한 공간이 아님
- \<meta\>: 어떤 목적을 위해 만들어진 데이터 ex)charset 지정 
	- viewport: 사용자에게 보여지는 화면 그 자체를 의미, 화면의 너비 정의 -> 픽셀도 가능하지만 initial-scale로 하면 페이지가 처음 로드될 때 확대/축소 수준을 제어
- \<charset\>: = unicode
- \<title\>: 화면의 제목, 검색 시 그대로 띄워짐
- \<link\>: 외부 리소스를 연결할 때 지정, 보통 css를 가져올때 지정
	- rel: html과 link로 가져오는 파일의 관계를 지정
	- href: 하이퍼 레퍼런스, 파일의 경로 지정  


### \<body\>
- 사용자에게 직접적으로 보여지는 영역
- 블록 레벨 요소 vs 인라인 요소
- block
    - 부모 요소의 전체 공간을 차지하여 블록을 만듦
    - 자식의 크기는 부모에 종속?
    - 한 라인에 한 요소만 존재
    - 부모의 높이와 자식의 높이가 다를 수 있다
    - 블록 레벨 요소 안에 인라인 요소 중첩 가능
    - 다른 요소들을 감싸서 하나의 큰 요소를 표현하기 위해 사용
    - ex: \<p\>, \<li\>, \<div\>  
- inline
    - 항상 블록 레벨 요소 안에 포함
    - 컨텐츠만큼 공간 차지, 보통 텍스트가 들어감
    - 새로운 줄을 만들지 않음
    - 인라인 요소 안에 블록 레벨 요소 중첩 불가능
	    - 예외: \<a\>(앵커)태그: 하이퍼링크 연결
	        왜? -> 통째로 눌러야 하는 경우 때문에
    - 크기를 지정할 수 없고 padding, border과 상하부분을 제외한 margin 속성 사용 가능
    - ex: \<span\>, \<a\>, \<label\>, \<input\>  
-  inline-block
    - 줄바꿈이 안되고, 크기 조정이 됨
    - ex: \<button\>  

- \<div\>
    - 컨텐츠 분할 요소, 여러 태그를 그룹핑하기 위한 요소
    - div는 컨텐츠를 감싸고 끝 -> 특정한 모양이 없음
    - 의미가 없는 태그 -> 스타일 적용을 위한 용도로 사용하고, 의미가 있는 태그들 위주로 사용할 것  


- \<span\>
    - 얘도 의미 없는 요소
    - 사용 지양  


- \<header\>
    - 로고, 회사명, 검색폼 등 -> 소개 및 탐색에 도움
    ![header_example](img/content/header_example.png)
    - 왜 네이버는 header를 안 쓸까?
        - header태그는 이전 브라우저에서는 인식할 수 없음 -> 예전 버전의 브라우저를 이용하는 사용자들을 위해서
    - 중첩 사용 불가능, 헤더 안에 footer도 불가
    - 디자인적인 변화는 없음  


- \<nav\>
    - 네비게이션
    - 보통 헤더안에 들어가있음- 브레드크럼은 header안에 없어도 됨
    - 보통 리스트 형태가 많음
    - 주요 탐색을 위한 링크  


- \<footer\>
    - 페이지 작성자, 저작권 정보, 관련 문서 등의 내용  


- \<main\>
    - body의 주요 컨텐츠를 나타냄
    - 웹페이지에서 한 번만 사용 가능
    - 여러 페이지에 반복되는 컨텐츠를 포함하면 안 됨
        ex: 검색폼, 로고, 사이드바, 탐색 링크 등
    - role은 적극적으로 사용하면 안 된다. 정 없을때 사용  


- \<article\>
    - 독립적으로 구분해 배포하거나 재사용할 수 있는 구획 ex: 네이버 로그인
    - 어디에 들어가도 별 문제 없을 것 같은 애들
    - 자식 요소로 제목 요소(h1 ~ h6)가 들어가야함


- \<section\>
    - 일반적이고 독립적인 섹션
    - 제목과 내용을 포함한 하나의 정보 덩어리
    - 보통 시리즈로 구성되어 있음 ex: 짜장면 레시피 -> 짜장면 정의 / 짜장면 종류 ...
    - 제목 요소를 자식으로 포함해야 함  

- \<article\>과 \<section\>
    - 기능상, 외관상의 차이점은 없음, 단지 의미의 차이  


- \<aside\>
    - 문서의 주요 내용과 간접적으로 연관된 부분
    - 보조적인 역할만 함 ex: 각주, 광고 배너


- 제목 요소
    - h1 ~ h6순으로 사용하며, 순서대로 들어가야 함
    - HeadingsMap을 사용하면 태그별로 구별하여 보여줌  


- \<a\>
    - 하이퍼링크를 만드는 요소
    - tel은 전화, mailto는 메일
    - _self: 해당 탭에서 바뀜
    - _blank: 새 탭
    - target=로 속성 추가
    - download -> 다운로드
    - 앵커 안에는 컨텐츠가 반드시 들어가야 함
    - 네비게이션으로 감쌈 -> 페이지 내부의 이동이어서
    - 해시태그로 이동하게 되면 url의 맨 뒤에 정보가 붙게 됨    
    
- \<p\>
    - paragraph, 문단
    - 이미지나 입력폼 등 관련있는 모든것 가능, 블록 요소  

- \<strong\>
    -중대하거나 긴급한 컨텐츠, 굵은 글꼴 적용, 인라인 요소  

- \<br\>
    - break, 줄바꿈
    - html은 엔터 인식 X  

- \<hr\>
    - 주제가 변경되었을때, 단락을 구분할 때
    - 빈 태그(닫는 태그 없음)
    - 줄 그어지는 거  

- \<code\>
    - 짧은 코드조각을 나타낼 때(보통 한 줄)  

- \<pre\>
    - 그냥 텍스트를 썼을 때 텍스트 포맷 그대로 출력해주는 태그
    - 심지어 들여쓰기까지 다 나옴  

- \<ol\>
    - 순서가 있는 목록, type 지정 가능
    - ol의 자식은 반드시 li여야 함, 다른애들은 지정 불가
    - start로 시작 순서 지정 가능, reversed로 역순 가능  
    
- \<ul\>
    - 순서가 없는 목록, 주로 ·
- \<li\>
    - 목록의 항목을 나타냄, 단독 사용 불가능
- \<ol\>과 \<ul\>: 자손 요소로는 다른 태그도 가능  


- \<img\>
    - 문서에 이미지 삽입
    - src: 이미지 태그가 랜더링 해야하는 대상
    - alt: alternative: 대체 텍스트 -> 이미지를 설명해주는 용도
    - src와 alt는 반드시 존재해야 함
    - 이미지에 대한 설명이 있으면 alt에 중복 설명 하지 않기
    - 하지만 alt를 아예 빼면 안되기 때문에 alt=""같이 공백으로 지정해주기
    - 스크린리더에서 alt가 없으면 src의 경로를 다 읽어버리는 경우가 있음  
    - 밑에 노란 영역은 왜 생기냐?
        - 이미지는 인라인 요소임 -> 인라인 요소들은 기본적으로 텍스트를 표현하기 때문에 이미지가 텍스트는 아니지만 밑에 공간이 남음
    - 브라우저는 이미지를 한 글자로 인식함
    - 여백을 없애기 위해서는 vertical-align 속성을 사용함<br/><br/><br/><br/>


## 회고
