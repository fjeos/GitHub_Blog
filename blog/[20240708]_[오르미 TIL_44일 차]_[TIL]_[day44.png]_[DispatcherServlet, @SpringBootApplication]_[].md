주소 = endpoint

test : 사용자의 시나리오대로 테스트를 하는 것
단위 테스트: 각각의 계층을 따로따로해서 하는 테스트가 단위 테스트(레이어 단위)
의존성이 필요없음 -> 가짜 객체같은 걸 만들어서 사용
의존성을 분리시킴

통합 테스트 : 쉽게 말해 스프링부트 실행한 상태로 테스트

단위테스트가 속도가 빠름

트랜잭션
트랜잭션은 데이터 조작 관련 동작인데 레포지토리가 아니라 서비스단에서 처리해주나요?
트랜잭션이 데이터베이스 조작도 하지만 비즈니스 로직을 수행할 때 문제가 터지면 복구해야하기 때문에 비즈니스 로직이라고도 볼 수 있음
그래서 트랜잭션 어노테이션은 서비스 레이어에 붙임

@Transactional
붙이는 이유는 얘가 수행이 되면 반드시 데이터베이스에 적용이 되어야 함
안되면 에러가 터져야 함

Bean들은 다 싱글톤

@SpringBootApplication
main 에서 run을 호출하면서부터 시작

@Component Scan?
구동이 될 때 애들을 빈으로 만들어서 ioc 컨테이너에 넣어야 됨
근데? 메인은 아님 그래서 해줘야함
컴포넌트 스캔이 그 역할을 하는 것

컴포넌트도 빈으로 올라감
scanBasePackages() : base package를 기준으로 스캔

다양한 의존성 주입 방법
1. Setter 주입
세터메서드에 @Autowired -> 선택적

2. 필드 주입
필드 위에 @Autowired

@Primary 적혀있는게 우선
@Qualifier랑 뭐가 다를까?
primary는 우선 순위에 포커스
qualifier은 직접 명시
primary: 간택당하는게 아니라 내가 먼저 1순위로 나서서 주입을 받아버림
qualifier: 간택당하는 것
장단점이 뭐고 왜 생성자 주입이 쓰이는지 설명해주세요

final이 없었으면 내가 의존성 다 줘야했음
의존성이 많아질수록 길어짐

requiredArgsConstructor: 필요한 알규먼트들
생성자가 반드시 필요한 아규먼트들의 생성자를 만듦
final 키워드가 들어간 필드들은 생성자가 반드시 필요하기 때문에 requiredargs가 만들어줌


내부망 사용하는 곳은 외부 라이브러리를 사용하지 못할 수도 있음
자체적으로 라이브러리를 만들던가..

mock: 가짜
단위테스트에서는 의존성을 끊어내야함

디스패처 서블릿은 사용자의 요청을 적절한 컨트롤러에 배분하는 역할
사용자 요청 -> 디스패처 서블릿 -> 핸들러 매핑 -> 핸들러가 컨트롤러 선택
 -> 
SSR: 서버 사이드 렌더링
서버에서 화면(뷰)까지 렌더링해서 반환
서버에 부하가 심해짐 -> 뷰는 따로 FE에서 처리

디스패처 서블릿이란? spring MVC의 핵심 컴포넌트
모든  HTTP 요청을 받아 처리
http는 포트번호 80
2.2.2.2라는 곳에서 스프링을 띄웠어요
외부에서 내 스프링에 접근하려면 IP주소 2.2.2.2 뒤에 :포트번호 붙이기
중국 = 컴퓨터
항구 = 포트번호


httpServletRequest 요청을 중점적으로 처리