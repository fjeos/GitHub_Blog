
## 사용자로부터 입력 받기
<br><br>

#### import
- import 예약어를 통해 외부/jdk 기본 라이브러리를 가져와서 사용 가능
- 라이브러리에 웬만한 요구사항들을 충족하는 기능들은 이미 다 개발되어 있음
- `import java.util.*` 이렇게 사용도 가능  
&nbsp;&nbsp;&nbsp;&nbsp;but -> util 밑의 모든 클래스를 import 하기 때문에 비효율적  
-import 시에는 직접 명시하는 게 좋음  
<br><br>

#### Scanner
```java
import java.util.Scanner;
```
util에서 Scanner 클래스를 import 하는 방법  
- 스캐너는 계속 메모리를 점유 -> close로 입력을 끊어줘 메모리 효율성 향상
`nextLine()`은 개행문자(`\n`)까지 입력으로 읽어들이는 반면,  
`nextInt()`는 개행문자 이전까지 읽어들이므로 `nextInt()` 다음에 `nextLine()`을 쓰면 의도치 않은 동작을 할 수 있음  
따라서 `nextInt()` 다음엔 `nextLine()`으로 개행문자를 제거해줘야 함  
<br>

##### stream
- 입력을 받거나, 출력하는 과정을 하나의 흐름(stream)이라고 표현
- System.in: 표준 입력
- System.out: 표준 출력
<br><br>

#### Random
- java.util 안에 있는 라이브러리
- `nextInt()`: int 타입의 난수 생성
- `nextInt(int bound)`: 0부터 bound 미만의 int 타입 난수 생성
<br><br>

#### JVM, GC, .class 
- 자바 실행 흐름: .java 파일 생성 -> javac (컴파일러) : javac HelloWorld.java 실행 -> 컴파일 수행  
-> 소스 코드를 바이트 코드로 변환 -> .class 파일 생성 -> java HelloWorld 입력 -> JVM이 바이트 코드를 읽어 실행
<br>

##### JVM이 어떻게 바이트 코드를 읽나?
1. 클래스 로더 시스템: "HelloWorld.class"파일을 메모리에 로드, 필요한 다른 클래스도 로드  
-선언한 변수, 등등.. 메모리에 적재  
2. 실행 엔진: 로드된 바이트 코드 실행  
-인터프리터는 바이트 코드를 한 줄씩 읽어 실행, 만약 같은 코드가 반복되면 JIT 컴파일러가 해당 부분을 기계어로 컴파일하여 직접 실행  
3. 런타임 데이터 영역: JVM은 프로그램 실행에 필요한 메모리를 할당 받음  
<br>

**❗중요❗면접 단골 질문**  
- 메서드 영역: 클래스 정보, 상수, static 변수 등이 저장
- 힙: 객체와 배열이 생성되는 공간
- 스택: 메서드 호출 시 지역 변수, 매개 변수, 리턴 값 등이 저장
- PC 레지스터: 현재 실행 중인 명령의 주소를 저장
- 네이티브 메서드 스택: 자바 외의 언어(보통 C/C++)등로 작성된 네이티브 코드를 위한 공간
<br><br>

##### GC(가비지 콜렉터)
- 안 쓰는 변수에 대한 메모리를 확보
- 힙 영역에 더 이상 참조되지 않는 객체가 있을 때 실행
<br><br><br>


## 🎸기타 정보
ArrayList 선언하기  
```java
ArrayList<Integer> list = new ArrayList<>();
```
- 일반 배열보단 ArrayList가 많이 쓰임  
-> 왜? 일반 배열과 달리 ArrayList는 동적 추가가 가능
- 꺾쇠 안은 타입 -> 이 타입만을 가지는 리스트를 만듦

**❗중요❗**
##### Wrapper Class
- 기본 타입들을 클래스로 사용하기 위해 존재
- int -> Integer / double -> Double / boolean -> Boolean ...
- boxing
<br><br>

- 스터디/사이드 프로젝트 많이 함
<br><br><br><br>

## 💭회고