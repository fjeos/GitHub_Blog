## 목차
1. [반복문](#반복문)  
  1-1. [do-while 반복문](#do-while-반복문)  
2. [type](#type)  
  2-1. [원시 타입](#원시-타입primitive-types)  
  2-2. [객체 타입](#객체-타입object-types)  
3. [배열](#배열)  
  3-1. [스택과 큐](#스택과-큐)  
  3-2. [배열의 여러 가지 메소드](#배열의-여러-가지-메소드)  
4. [기타 정보](#기타-정보)  
5. [회고](#회고)  

<br><br><br><br>

## 반복문
for문의 중첩은 되도록 한 번만 하자     
<br><br>

#### do-while 반복문
- 최초 한번은 입력을 보장
- 조건식이 거짓이더라도 반복문이 최소한 한 번은 실행되어야 할 때 사용
&nbsp;&nbsp;&nbsp;&nbsp;ex) 사용자로부터 입력을 받는 코드를 작성할 때  
<br><br>

##### 브라우저에서 무한 루프 구현
- window.requestAnimationFrame() = requestAnimationFrame()
- window = browser
- 윈도우는 생략 가능
- 탭이 비활성화 되면 멈췄다가 활성화 됐을 때 다시 실행  
<br><br>

##### NaN == NaN이 false가 나오는 이유
- 메모리상의 주소와는 상관이 없이 애초에 NaN과 다른 NaN은 같지 않도록 설계 됨
- NaN인지 아닌지 확인하는 법: isNaN -> 전달 받은 값이 숫자가 아닌 것인지 확인  
- '10'같은 경우는 문자열인데 숫자로 전환이 가능한 문자
- 이런 기능을 '묵시적 형변환'이라고 함  
<br><br><br>

## type
- 자료형
<br><br><br>

#### 원시 타입(Primitive Types)
- 값을 변경할 수 없음
- 값을 변수에 저장하거나 전달할 때 값에 의한 전달을 함
- 값의 참조가 아닌 값 자체를 전달
- 대표적인 원시 타입: 숫자  
![primitive type 예시](img/content/primitive-type.webp)  
- str1이 가지고있는 값을 str2에 할당 -> H1을 바라보게 만드는게 아니라 또다른 H를 만들어서 바라보게 함
- 결과적으로 현재 다른공간을 바라보고 잇음
- 그래서 str1이 변경되어도 str2에 영향을 끼치지 않음  
<br><br>

#### 객체 타입(Object Types)
- 상태를 가지는 타입
- 프로퍼티 값과 메서드를 가지며, 객체의 상태와 동작을 나타냄
- 메서드 = 함수  
![object type 예시](img/content/object-type.jpg)  


##### autoboxing
```js
let val = 'hello!';
console.log(val.toUpperCase());

// 위의 코드가 내부적으로는 아래처럼 실행됩니다. 이것이 바로 autoboxing 입니다.
let val = 'hello!';
let temp = new String('hello!');
console.log(temp.toUpperCase());
temp = null;
```
- 원시타입도 객체타입처럼 사용할 수 있도록 하는 것
- 일관적인 사용 경험을 사용자에게 제공하기 위함  
<br><br><br>


## 배열
```js
const arr1 = [1, 2, 3, 4, 5];
arr1[2] = 30;
```
- const arr2 = new Array(4, 5, 6); 이렇게 생성하는 것은 권장하지 않음 (일반적이지 않음)
- .length는 인덱스 넘어가도 undefined가 나오고 오류가 나지 않음
- a.length = 100처럼 변경 가능하지만 일반적으론 절대 만지지 않음
- myArray.length = myArray['length']
- myArray[length]는 윈도우의length 임(window.length) -> 기본적으로 선언되어있는 것
- 1차원은 vector
- 2차원은 matrix
- 3차원 이상은 tensor
<br>

**❓const인데 배열이 변경이 되나요?**
&nbsp;&nbsp;->네 됩니다
- const는 데이터 자체가 아니라 주소를 저장하고 있기 때문에 객체를 변경해도 바뀌지 않음
- 배열은 객체타입
- 원시타입은 값을 복사해서 새로 만들지만, 객체는 그렇지 않으므로 유의해야함
- 같은 주소를 바라보기 때문에 하나가 변경되면 같이 변경됨  
<br>

❓ **배열을 사용할 때 const를 사용하는 이유가 주소값은 변하지 않기 때문인가요?**
- 그것도 맞고 대부분 변수에는 const를 사용
- var는 사용하지 말고 문제가 생기는 경우에만 let 사용
- 가독성이 높아진다
- const를 사용했을 때 배열은 문제가 되지 않는다  
&nbsp;&nbsp;&nbsp;&nbsp; -> 왜? 메모리에는 주소값이 저장되어있고 해당 주소에서 값이 변경되기 때문에  
&nbsp;&nbsp;&nbsp;&nbsp; -> 시작값만 가지고 있으면 된다  
- x가 리스트를 가리키고 있다는게 변경이 불가능 한 것이고, 리스트 값은 변경 가능  

>💡원시 타입에서,  
&nbsp;&nbsp;a = 30, b = a 일때 b의 주소에 30이 저장됨  
&nbsp;&nbsp;&nbsp;&nbsp;->자바스크립트만의 특징  
&nbsp;&nbsp;자바스크립트는 여러 브라우저가 있는 상태에서 합의를 통해 표준이 나왔기 때문에 데이터 저장 방법도 브라우저마다 다름  
&nbsp;&nbsp;&nbsp;&nbsp;=> 실행 엔진이 다르다  
&nbsp;&nbsp;실제로 브라우저에서는 최적화를 위해 저장하지 않고 가리키게 함  
<br><br>

#### 스택과 큐
- 자료구조: 자료를 어떻게 저장할 것인가
![스택과 큐](img/content/스택큐.webp)
- 스택: 마지막에 들어간게 먼저 나간다
- 큐: 먼저 들어간게 먼저 나간다
- 앞에서만 빼고 나가도 한쪽에서만 이루어지기 때문에 스택이 될 수 있다
- push - pop / unshift - shift는 짝
<br>

**❓다음 중 스택이 될 수 없는 것은? 넣는 순서는 A, B, C, D, E**
1. E, D, C, B, A
2. C, B, A, E, D
3. C, B, A, D, E
4. A, B, C, D, E  
정답: 전부 다 가능하다  
<br><br>

#### 배열의 여러 가지 메소드
##### push(), pop()
- push: 배열의 맨 뒤에 요소를 삽입 후 길이 반환
- pop: 배열의 맨 뒤 요소를 삭제한 후 반환
<br><br>

##### shift(), unshift()
- unshift: 맨 앞에 요소를 추가
- shift: 맨 앞의 요소를 삭제 후 반환
<br><br>

##### splice()
- 배열의 요소를 추가/제거/교체
>splice(a, b, c)
- a: 삭제하거나 추가할 인덱스
- b: 삭제할 요소의 개수
- c: 추가할 요소
- 추가되는 값을 주지 않으면 삭제 가능  
&nbsp;&nbsp;&nbsp;&nbsp;ex) arr.splice(1, 1);  
<br><br>

##### slice()
- end 인덱스 -1 까지 슬라이싱
![slice](img/content/slice.png)  
-마지막 인덱스인 4에서 -1인 3인덱스(값 4)까지 slice 됨  
- 배열의 크기를 넘어도 에러를 내지 않음
- 아무 값을 주지 않으면 처음부터 끝까지 다 자름
<br><br>


##### sort()
- 정렬에 대한 표준이 없음 -> 브라우저마다 다른 정렬 알고리즘 사용
- 요즘은 tim sort를 많이 사용
- [1, 22, 3, 11, 33, 2] 이런 배열이 있을 때sort()가 사전식 정렬이라 1, 11, 2, 22... 이렇게 됨(유니코드 기반)
- 그럼 어떻게 하지? -> sort(function()): 함수에 비교 로직 구현
```js
const arr = [1, 11, 3, 22, 2, 33];
console.log(arr.sort((a, b) => a - b));
```
- abab: 오름차순
- abba: 내림차순
- a - b > 0: a가 b보다 크므로 a가 뒤로 감
- a - b < 0: a가 b보다 작으므로 a가 앞으로 감
- a - b == 0: a와 b가 같으므로 변화 없음
- 반대로 하면 내림차순 정렬  
<br><br>

##### forEach()
![forEach](img/content.forEach.png)  
- 각각의 요소를 순회할 때 사용
- sort와 같이 forEach(function())으로 로직 지정
- 주로 화살표 함수 사용
- 인자로 item, index, arr를 줄 수 있음
- arr는 내가 순회돌고 있는 arr를 같이 표현 -> 거의 안 씀
<br><br>

##### map()
- 배열의 각 요소에 주어진 함수를 실행하여 새로운 결과를 배열로 반환
- 첫 번째 인덱스: 배열의 각 요소를 처리할 함수
- 두 번째 인덱스: 요소의 인덱스
- 데이터를 뽑아내는 데 많이 사용
<br><br>

###### 💡forEach vs map 뭐가 다를까?
map은 새로운 배열을 만들어주고, forEach는 아님
<br><br>

##### filter()
- 조건에 맞는 요소만 추출
- map은 리턴한 값으로 배열을 만들고 filter은 조건을 확인해서 그게 true인지 아닌지로 배열을 만듦
- 조건 여부가 아니라 리턴한 값이 true인지 아닌지를 확인하는 점이 다른 것
<br><br>

##### includes()
요소가 포함 되어있으면 true, 아니면 false
<br><br>

##### 객체
- key-value쌍으로 이루어져있음
- key와 value는 콜론으로 구분
- 키 값 쌍을 합쳐 자산(properties)라고 함
- 콜론, 컴마 뒤에는 한 칸 공백을 두는게 권고사항
- 프로퍼티 값이 함수인 경우에는 메소드라고 부름
- 다른 언어에 있는 메소드 개념하고 조금 다름
- 최신 문법을 사용하면 fuction 키워드 없어도 됨
<br><br>

## 기타 정보
- 코드 순서에 따라서 결과가 달라질 수 있다
- 데이터가 없는 상태를 명시적으로 일컫는 값이 null
- undefined나 null이나 하는건 똑같음
- 배열 메서드를 이어서 쓸 수 있음
&nbsp;&nbsp;&nbsp;&nbsp;ex) arr.slice(1, 0, 4).filter(....)  
- 선생님이 그렇게 얘기했으니까 그런거겠지. 라고 넘어가지 말기
- 손코딩이 도움이 된다
- 일단 출석을 한다는것 자체로 잘 하고 있는 것!
- 너무 스스로를 쪼지 말 것
- 자연스럽게. 너무 하드하게 말고
- 계속해서. 끊임없이. 하다보면은 길이 열릴 것이다
- 실력이 있으면 인정 받는다
<br><br><br><br>



## 회고
오늘은 자바스크립트 배열과 여러 메소드들에 대해서 배웠다.  
생각보다 파이썬이랑 비슷한 부분이 많아서 놀랐다.  
자바스크립트를 주 언어로 쓰는 친구가 파이썬은 너무 경량화돼서 싫다고 했는데...  
비슷한데...?  
암튼...  
중간에 스택이랑 큐 문제를 못 맞춰서 자존심 상한다!!  
3번이 맞는거 알고 있었으면서 다른 번호 시뮬레이션 돌리고 오는동안 까먹어서 3번이라고 외치고 있네...  
그냥 정답이 없는 경우를 생각 못 했을지도..?  
앞으로 이런 실수는 하지 않기...😔  
